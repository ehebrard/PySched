\section{Precedence Graph}

		
% 1/ Precedence graph / difference system -> convenient way of implementing	domains
		
% 1/ CP branching does not work
% 2/ Schedule or postpone is good but not great and not standard branching
% 3/ Idea of branching on precedences
% 4/ Branching on precedences performs surprisingly well
% 5/ Some explanation ?
% 6/ Precedence graph / difference system -> convenient way of implementing this
		
		
% \begin{frame}
% 	\frametitle{Search}
%
% 	\begin{itemize}
% 		\item
% 		\begin{itemize}
% 			\item Choose task $i$ minimizing $\lct{i} - \est{i} - \dur{i}$ (and/or most constrained by resources and precedences)
% 			\item Set $\stof{i}$ to $\est{i}$
% 			\item When backtracking, set $\stof{i}$ to $\est{i}+1$
% 		\end{itemize}
% 		\item ``Schedule or postpone'' $\simeq$ branch on the task to start at the first available slot
% 		\begin{itemize}
% 			\item Circumvent the precision problem, usually efficient for makespan minimization
% 			\item Non trivial to implement in a classical CP solver
% 			\item Might be incomplete for some objectives or constraints
% 		\end{itemize}
% 	\end{itemize}
%
% \end{frame}


\begin{frame}
	\frametitle{The importance of search: a short story}

	\begin{columns}
	\begin{column}{0.5\textwidth}
		
		\only<1-2> {
			\begin{itemize}
				\item Jobs: Files to transfer
				\item Resources:
				\begin{itemize}
					\item \memph{Download channels}: at most that many simultaneous downloads
					\uncover<2-> {
					\begin{itemize}
						\item \emph{Cumulative resource shared by every task}
					\end{itemize}
					}
					\item \memph{Memory banks}: cannot download two files stored on the same memory bank simultaneously
					\uncover<2-> {
					\begin{itemize}
						\item \emph{Tasks partitioned in as many unary resources as memory banks (\memph{$m$})}
					\end{itemize}
					}
				\end{itemize}
				\item Download as much data as possible within a given time window
				\uncover<2-> {
				\begin{itemize}
					\item \emph{Minimize makespan}
				\end{itemize}
				}
			\end{itemize}
			}
			
			\only<3-> {
				\begin{itemize}
					\item Alas, our method was hardly better than a very basic greedy algorithm...
				\end{itemize}
			
				\begin{myblock}{Greedy algorithm}
					\begin{itemize}
						\item \textbf{Repeat:}
						\begin{itemize}
						\item Choose the largest task \memph{a} from the resource with highest demand
						\item Schedule \memph{a} as soon as possible
						\end{itemize}
					\end{itemize}
				\end{myblock}
			
				\uncover<4->{
				% \begin{myblock}{Approximation ratio}
					\begin{itemize}
						\item Approximation ratio: \memph{$ 2 - \frac{2}{m+1} $} \mycite{HebrardEtAl16}
						\uncover<5->{
						\item Approximation ratio: \memph{$ 1 + \rho \frac{m-1}{n} $} where \memph{$\rho$} is the ratio between largest and smallest task size
						}
					\end{itemize}
				% \end{myblock}
				}
				
				\uncover<6->{
					Not \memph{all} resource scheduling are hard!
				}
			}

	\end{column}
	\begin{column}{0.5\textwidth}  %%<--- here
		
		\begin{center}

	     \includegraphics[width=0.8\textwidth]{im/satellites.jpg}
			 
			 \includegraphics[width=0.8\textwidth]{im/station.jpg}

		\end{center}
		
	\end{column}
	\end{columns}
	

\end{frame}

		

\begin{frame}
	\frametitle{Search strategy}

	\begin{itemize}
		\item Default CP strategy is a very bad idea:
		\begin{itemize}
			\item Choose task \memph{$i$} minimizing \memph{$\lct{i} - \est{i} - \dur{i}$} (and/or most constrained by resources and precedences)
			\item Branch on \memph{$\stof{i} = \est{i}$ or $\stof{i} > \est{i}$}: create ``holes'', dependent on the precision
			% \item When backtracking, set $\stof{i}$ to $\est{i}+1$
		\end{itemize}
		\item ``Schedule or postpone'' $\simeq$ branch on the task to start at the first available slot
		\begin{itemize}
			\item Circumvent the precision problem, usually efficient for makespan minimization
			\item Non trivial to implement in a classical CP solver
			\item Might be incomplete for some objectives or constraints
		\end{itemize}
		\item Sophisticated techniques in the latest CP solver (CP Optimizer) \mycite{VilimEtAl15}
		\begin{itemize}
			\item Alternate between Large Neighborhood Search and ``Failure Directed Search''
		\end{itemize}
	\end{itemize}

	% \begin{myblock}{Branch on precedences \mycitation{Cesta and Odi}}
	% 	\begin{itemize}
	% 		\item For unary resources: one Boolean variable per disjunctive constraint
	% 	\end{itemize}
	% \end{myblock}

\end{frame}


\newcommand{\bestopt}[1]{\cellcolor{bostonuniversityred}{\bf \textcolor{white}{#1}}}
\newcommand{\best}[1]{\cellcolor{airforceblue}{\bf \textcolor{white}{#1}}}



\begin{frame}
	\frametitle{Precedence graph / Difference system}

	\begin{center}
		\begin{colorschedfigure}{.5}
			\input{ex/scheduling_instance.tex}
		\end{colorschedfigure}


		\begin{colorschedfigure}{.55}
			\input{ex/precedence_graph.tex}
		\end{colorschedfigure}
	\end{center}
\end{frame}


\begin{frame}
	\frametitle{Precedence graph as ``domain''}

	\begin{center}
		\begin{colorschedfigure}{.55}
			\uncover<1>{
				\input{ex/precedence_graph.tex}
			}
			\uncover<2->{
				\input{ex/precedence_graph_lb.tex}
			}
			\uncover<3->{
				\input{ex/precedence_graph_ub.tex}
			}
		\end{colorschedfigure}
	\end{center}

	\uncover<2->{
	\begin{itemize}
		\item Lower bound of node \memph{$x$} is \memph{$-\dur{0,x}$} where \memph{$\dur{0,x}$} is the shortest path from \memph{$0$} to \memph{$x$}
		\uncover<3->{
		\item Upper bound of node \memph{$x$} is \memph{$\dur{x,0}$}
		}
	\end{itemize}
	}

\end{frame}


\begin{frame}
	\frametitle{Precedence graph as ``domain''}

	\begin{itemize}
		\item Convenient way to implement the domain / solution space
		\begin{itemize}
			\item Fewer concepts (\memph{nodes, arcs} vs. min/max duration $\dur{i}$, release and due dates $\est{i},\lct{i}$, precedences)
			\item Clean propagation
			\begin{itemize}
				\item Lower, upper bounds and negative cycles: \mycitation{Bellman--Ford}
				\item Transitive closure on precedences: \mycitation{Floyd--Warshall}
			\end{itemize}
		\end{itemize}
	\end{itemize}
	


\end{frame}


\begin{frame}
	\frametitle{Precedence search}

	\begin{myblock}{Search on the precedence graph}
		\begin{itemize}
			\item Variable \memph{$\precvar{i}{j}$} standing for \memph{$i \prec j$} for each pair of tasks \memph{$i,j$} sharing a resource
		\end{itemize}		
	\end{myblock}
	\vspace{-.75cm}
	\begin{center}
		\begin{colorschedfigure}{.65}
				\input{ex/precedence_graph.tex}
				\uncover<2->{
					\path (x4) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} (x7);
					\path (x6) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} (x5);
				}
				\uncover<3->{
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x11);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x11);
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
				}
		\end{colorschedfigure}
	\end{center}

	
\end{frame}



\begin{frame}
	\frametitle{Precedence search}

	\begin{myblock}{Search on the precedence graph}
		\begin{itemize}
			\item There is a solution iff there is no negative cycle (no need to assign the start times)			
			\item Disjunctive constraints (\memph{$\forall i,j~ \precvar{i}{j} \implies i \prec j; \precvar{i}{j} \neq \precvar{j}{i}$})
			% \begin{itemize}
			% 	\item Unary constraints: complete the subgraph corresponding to a resource
			% \end{itemize}
			% \item Look-ahead much harder for cumulative resource, but checking a complete graph is still easy
		\end{itemize}		
	\end{myblock}
	\vspace{-.75cm}
	\begin{center}
		\begin{colorschedfigure}{.6}
				\input{ex/precedence_graph.tex}
					\path (x4) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x7);
					\path (x6) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x5);
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x11);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x11);
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
		\end{colorschedfigure}
	\end{center}

	
\end{frame}



\begin{frame}
	\frametitle{Precedence search}

	\begin{myblock}{Search on the precedence graph}
		\begin{itemize}
			\item Cumulative constraints ($\forall i,j~ \precvar{i}{j} \implies i \prec j; \memph{\neg \precvar{i}{j} \vee \neg \precvar{j}{i}}$)
			\uncover<2->{
			\[
			\memph{\forall \Omega~ \sum_{i \in \Omega} \demand{i} > \capacity \implies \sum_{i \in \Omega}\sum_{j \in \Omega}\precvar{i}{j} > 0} 
			\]
			}
		\end{itemize}		
	\end{myblock}
	\vspace{-.75cm}
	\begin{center}
		\begin{colorschedfigure}{.6}
				\input{ex/precedence_graph.tex}
					\path (x4) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x7);
					\path (x6) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x5);
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x11);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
					\path (x10) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x11);
					\path (x8) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{B}{C}$}} 
					(x13);
					\path (x12) edge[dashed, ->, thick, shorten >=1mm,shorten <=1mm] 
					%node[labelstyle, near start] {\textcolor{black}{$\precvar{C}{B}$}} 
					(x9);
		\end{colorschedfigure}
	\end{center}

	
\end{frame}



\begin{frame}
	\frametitle{Conflict directed scheduling \mycite{GrimesHebrard15}}

		\begin{columns}

			\column{.1\textwidth}

			\column{.4\textwidth}
			\begin{myblock}{Conflict weighting}
				\begin{itemize}
					\item Only disjunctive constraints, one Boolean variable for each
					\item Weighted Degree: choose the tasks involved in the most \memph{conflicts}
					\item Branch on the Boolean variables (post precedence one way)
				\end{itemize}
			\end{myblock}

			\column{.4\textwidth}
			\begin{myblock}{IBM CP Optimizer}
				\begin{itemize}
					\item Every algorithm seen here and use Cplex linear relaxation
					\item Alternate large neighborhood search and strong lower bounds from Cplex
					\item Specialized strategies and auto-tuning
				\end{itemize}
			\end{myblock}

		\end{columns}

		\medskip

		\tabcolsep=0pt
		\uncover<2-> {
		\begin{tabular}{C{.15\textwidth}C{0pt}C{.21\textwidth}C{3pt}C{.19\textwidth}C{12pt}C{.21\textwidth}C{3pt}C{.19\textwidth}}
			 && Objective && Proof && Objective && Proof \\
		\end{tabular}
		}\uncover<2-> {
		\begin{tabular}{C{.15\textwidth}C{0pt}C{.21\textwidth}C{3pt}C{.19\textwidth}C{12pt}C{.21\textwidth}C{3pt}C{.19\textwidth}}
			$C_{max}$ && 0.50\% && \bestopt{75\%} && \best{0.03\%} && 56\% \\
		\end{tabular}
		}\uncover<3-> {
		\begin{tabular}{C{.15\textwidth}C{0pt}C{.21\textwidth}C{3pt}C{.19\textwidth}C{12pt}C{.21\textwidth}C{3pt}C{.19\textwidth}}
			$setup$ && \best{0.00\%} && \bestopt{52\%} && 0.27\% && ~4\% \\
		\end{tabular}
		}\uncover<4-> {
		\begin{tabular}{C{.15\textwidth}C{0pt}C{.21\textwidth}C{3pt}C{.19\textwidth}C{12pt}C{.21\textwidth}C{3pt}C{.19\textwidth}}
			$lags$ && \best{0.39\%} && \bestopt{64\%} && 0.54\% && 22\% \\
				\end{tabular}
		}\uncover<5-> {
		\begin{tabular}{C{.15\textwidth}C{0pt}C{.21\textwidth}C{3pt}C{.19\textwidth}C{12pt}C{.21\textwidth}C{3pt}C{.19\textwidth}}
			$T_{\sum}$ && \best{1.59\%} && \bestopt{73\%} && 2.52\% && 33\% \\
		\end{tabular}
		}

\end{frame}

% \begin{frame}
% 		\begin{tikzpicture}[scale=.55]
% 				\input{ex/g1.tex}
% 		\end{tikzpicture}
% \end{frame}
%
% \begin{frame}
% 		\begin{tikzpicture}[scale=.55]
% 				\input{ex/g2.tex}
% 		\end{tikzpicture}
% \end{frame}
%
%
% \begin{frame}
% \frametitle{Search} % on \mycitation{Hurley j3per0_2.txt}}
%
% \begin{center}
% 	\begin{colorschedfigure}{.45}
% 		\input{ex/tracej3p02.tex}
% 	\end{colorschedfigure}
%
%
% \uncover<44->{
%
% 	% \begin{center}
% 		\begin{tabular}{C{1cm}|L{2cm}|L{7cm}}
%
% 			level
% 			&
% 			decisions
% 			&
% 			deductions
% 			\\
%
% 			\hline
%
% 			\only<49->{0.}
% 			&
% 			&
% 			\only<49->{{\normalsize $F_2 \prec F_0$}}\only<53->{{\normalsize $,F_1 \prec F_2$}$~\Rightarrow \perp$}
% 			\\
%
% 			\only<44-48>{1.}\only<50-52>{1.} & \only<44-48>{\memph{$F_0 \prec F_2$}}\only<50-52>{\memph{$F_2 \prec F_1$}}
% 			&
% 			\only<44-48>{{\normalsize $D_2 \prec F_2, E_2 \prec F_2$}}\only<48>{{\normalsize $,F_2 \prec F_1$}}\only<52>{{\normalsize $F_0 \prec F_1$}$~\Rightarrow \perp$}
% 			\\
%
% 			\only<45-47>{2.}\only<51>{2.} & \only<45-47>{\memph{$F_1 \prec F_2$}}\only<51>{\memph{$F_1 \prec F_0$}}
% 			&
% 			\only<47>{{\normalsize $F_1 \prec F_0$}$~\Rightarrow \perp$}
% 			%D_2 \prec F_2, E_2 \prec F_2,F_1 \prec D_1,
% 			%\ldots$}}
% 			%D_1 \prec D_0,D_1 \prec E_1,D_1 \prec D_2,F_1 \prec E_1, E_2 \prec E_1, E_2 \prec D_2$}}
% 			\\
%
% 			\only<46>{3.} & \only<46>{\memph{$F_0 \prec F_1$}}
% 			&
% 			%\only<46>{{\normalsize $E_1 \prec E_2, E_1 \prec D_1, D_1 \prec F_1, F_0 \prec D_0$}}
% 			\only<46>{$~\Rightarrow \perp$}
% 			\\
% 		\end{tabular}
% 	% \end{center}
% 	}
%
% \end{center}
%
% \end{frame}
%
% \begin{frame}
% 	\frametitle{Proof system}
%
% 	\begin{itemize}
% 		\item Proofs written with start times as variables can be rewritten with $O(n)$ precedences
% 		\begin{itemize}
% 			\item Proof system of Disjunctive alone is as strong as (not sure)
% 		\end{itemize}
% 		\item A precedence may require $O(h)$ bound expressions
% 		\item Of course propagation algorithms manipulate precedences
% 		\begin{itemize}
% 			\item However, they do not have explicit access to each-other precedences
% 			\item It may be possible that the proof system of solvers branching
% 		\end{itemize}
% 	\end{itemize}
%
% \end{frame}



% \begin{frame}
% \begin{tikzpicture}[opacity=.4]
% % \draw[block filldraw]              (0,0) rectangle (1,1)       ;
% % \node[block] (rect)             at (0,0)                 {test};
% % \node[block, anchor=south west] at (0,0)                 {test};
% % \node[from={0,0 to 2,.5}, color=egyptianblue, fill=white!40!blue(ncs)]                 {$a_1$};
%
% % \foreach \x/\y/\pos in {0/0/below,1/1/above,2/.5/right}
% %   \fill[opacity=1] (\x,\y) circle (1pt) node [\pos] {$\x,\y$};
% \end{tikzpicture}
% \end{frame}


% \begin{frame}
% 	\tikzset{edgestyle/.style={thick, shorten >=1pt, shorten <=1pt, -latex}}
% 	\tikzset{vertexstyle/.style={shape=circle,draw,inner sep=2pt}}
% 	\tikzset{labelstyle/.style={inner sep=2pt, fill=white, font=\tiny}}
% \begin{tikzpicture}[scale=.8]
% \input{ex/h.tex}
% \end{tikzpicture}
% \end{frame}
% \begin{tikzpicture}[scale=0.75,transform shape]
%   \Vertex[x=0,y=0](K)
%   \Vertex[x=0,y=2](F)
%   \Vertex[x=-1,y=4](D)
%   \Vertex[x=3,y=7](H)
%   \Vertex[x=8,y=5](B)
%   \Vertex[x=9,y=2](N)
%   \Vertex[x=5,y=0](M)
%   \Vertex[x=3,y=1](S)
%   \tikzstyle{LabelStyle}=[fill=white,sloped]
%   \tikzstyle{EdgeStyle}=[bend left]
%   \Edge[label=$120$](K)(F)
%   \Edge[label=$650$](H)(S)
%   \Edge[label=$780$](H)(M)
%   \Edge[label=$490$](D)(B)
%   \Edge[label=$600$](D)(M)
%   \Edge[label=$580$](B)(M)
%   \Edge[label=$600$](H)(N)
%   \Edge[label=$490$](F)(H)
%   \tikzstyle{EdgeStyle}=[bend right]
%   \Edge[label=$630$](S)(B)
%   \Edge[label=$210$](S)(N)
%   \Edge[label=$230$](S)(M)
% \end{tikzpicture}